// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'relation.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AtomTypeTearOff {
  const _$AtomTypeTearOff();

  IntAtomType intAtomType() {
    return const IntAtomType();
  }

  IntegerAtomType integerAtomType() {
    return const IntegerAtomType();
  }

  DoubleAtomType doubleAtomType() {
    return const DoubleAtomType();
  }

  TextAtomType textAtomType() {
    return const TextAtomType();
  }

  BoolAtomType boolAtomType() {
    return const BoolAtomType();
  }

  ConstructedAtomType constructedAtomType(
      String typeConstructorName, Map<String, AtomType> typeVarMap) {
    return ConstructedAtomType(
      typeConstructorName,
      typeVarMap,
    );
  }
}

/// @nodoc
const $AtomType = _$AtomTypeTearOff();

/// @nodoc
mixin _$AtomType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtomTypeCopyWith<$Res> {
  factory $AtomTypeCopyWith(AtomType value, $Res Function(AtomType) then) =
      _$AtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$AtomTypeCopyWithImpl<$Res> implements $AtomTypeCopyWith<$Res> {
  _$AtomTypeCopyWithImpl(this._value, this._then);

  final AtomType _value;
  // ignore: unused_field
  final $Res Function(AtomType) _then;
}

/// @nodoc
abstract class $IntAtomTypeCopyWith<$Res> {
  factory $IntAtomTypeCopyWith(
          IntAtomType value, $Res Function(IntAtomType) then) =
      _$IntAtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$IntAtomTypeCopyWithImpl<$Res> extends _$AtomTypeCopyWithImpl<$Res>
    implements $IntAtomTypeCopyWith<$Res> {
  _$IntAtomTypeCopyWithImpl(
      IntAtomType _value, $Res Function(IntAtomType) _then)
      : super(_value, (v) => _then(v as IntAtomType));

  @override
  IntAtomType get _value => super._value as IntAtomType;
}

/// @nodoc

class _$IntAtomType extends IntAtomType {
  const _$IntAtomType() : super._();

  @override
  String toString() {
    return 'AtomType.intAtomType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is IntAtomType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return intAtomType();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (intAtomType != null) {
      return intAtomType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return intAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (intAtomType != null) {
      return intAtomType(this);
    }
    return orElse();
  }
}

abstract class IntAtomType extends AtomType {
  const factory IntAtomType() = _$IntAtomType;
  const IntAtomType._() : super._();
}

/// @nodoc
abstract class $IntegerAtomTypeCopyWith<$Res> {
  factory $IntegerAtomTypeCopyWith(
          IntegerAtomType value, $Res Function(IntegerAtomType) then) =
      _$IntegerAtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$IntegerAtomTypeCopyWithImpl<$Res> extends _$AtomTypeCopyWithImpl<$Res>
    implements $IntegerAtomTypeCopyWith<$Res> {
  _$IntegerAtomTypeCopyWithImpl(
      IntegerAtomType _value, $Res Function(IntegerAtomType) _then)
      : super(_value, (v) => _then(v as IntegerAtomType));

  @override
  IntegerAtomType get _value => super._value as IntegerAtomType;
}

/// @nodoc

class _$IntegerAtomType extends IntegerAtomType {
  const _$IntegerAtomType() : super._();

  @override
  String toString() {
    return 'AtomType.integerAtomType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is IntegerAtomType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return integerAtomType();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (integerAtomType != null) {
      return integerAtomType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return integerAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (integerAtomType != null) {
      return integerAtomType(this);
    }
    return orElse();
  }
}

abstract class IntegerAtomType extends AtomType {
  const factory IntegerAtomType() = _$IntegerAtomType;
  const IntegerAtomType._() : super._();
}

/// @nodoc
abstract class $DoubleAtomTypeCopyWith<$Res> {
  factory $DoubleAtomTypeCopyWith(
          DoubleAtomType value, $Res Function(DoubleAtomType) then) =
      _$DoubleAtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$DoubleAtomTypeCopyWithImpl<$Res> extends _$AtomTypeCopyWithImpl<$Res>
    implements $DoubleAtomTypeCopyWith<$Res> {
  _$DoubleAtomTypeCopyWithImpl(
      DoubleAtomType _value, $Res Function(DoubleAtomType) _then)
      : super(_value, (v) => _then(v as DoubleAtomType));

  @override
  DoubleAtomType get _value => super._value as DoubleAtomType;
}

/// @nodoc

class _$DoubleAtomType extends DoubleAtomType {
  const _$DoubleAtomType() : super._();

  @override
  String toString() {
    return 'AtomType.doubleAtomType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DoubleAtomType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return doubleAtomType();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (doubleAtomType != null) {
      return doubleAtomType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return doubleAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (doubleAtomType != null) {
      return doubleAtomType(this);
    }
    return orElse();
  }
}

abstract class DoubleAtomType extends AtomType {
  const factory DoubleAtomType() = _$DoubleAtomType;
  const DoubleAtomType._() : super._();
}

/// @nodoc
abstract class $TextAtomTypeCopyWith<$Res> {
  factory $TextAtomTypeCopyWith(
          TextAtomType value, $Res Function(TextAtomType) then) =
      _$TextAtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$TextAtomTypeCopyWithImpl<$Res> extends _$AtomTypeCopyWithImpl<$Res>
    implements $TextAtomTypeCopyWith<$Res> {
  _$TextAtomTypeCopyWithImpl(
      TextAtomType _value, $Res Function(TextAtomType) _then)
      : super(_value, (v) => _then(v as TextAtomType));

  @override
  TextAtomType get _value => super._value as TextAtomType;
}

/// @nodoc

class _$TextAtomType extends TextAtomType {
  const _$TextAtomType() : super._();

  @override
  String toString() {
    return 'AtomType.textAtomType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TextAtomType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return textAtomType();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (textAtomType != null) {
      return textAtomType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return textAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (textAtomType != null) {
      return textAtomType(this);
    }
    return orElse();
  }
}

abstract class TextAtomType extends AtomType {
  const factory TextAtomType() = _$TextAtomType;
  const TextAtomType._() : super._();
}

/// @nodoc
abstract class $BoolAtomTypeCopyWith<$Res> {
  factory $BoolAtomTypeCopyWith(
          BoolAtomType value, $Res Function(BoolAtomType) then) =
      _$BoolAtomTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$BoolAtomTypeCopyWithImpl<$Res> extends _$AtomTypeCopyWithImpl<$Res>
    implements $BoolAtomTypeCopyWith<$Res> {
  _$BoolAtomTypeCopyWithImpl(
      BoolAtomType _value, $Res Function(BoolAtomType) _then)
      : super(_value, (v) => _then(v as BoolAtomType));

  @override
  BoolAtomType get _value => super._value as BoolAtomType;
}

/// @nodoc

class _$BoolAtomType extends BoolAtomType {
  const _$BoolAtomType() : super._();

  @override
  String toString() {
    return 'AtomType.boolAtomType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BoolAtomType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return boolAtomType();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (boolAtomType != null) {
      return boolAtomType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return boolAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (boolAtomType != null) {
      return boolAtomType(this);
    }
    return orElse();
  }
}

abstract class BoolAtomType extends AtomType {
  const factory BoolAtomType() = _$BoolAtomType;
  const BoolAtomType._() : super._();
}

/// @nodoc
abstract class $ConstructedAtomTypeCopyWith<$Res> {
  factory $ConstructedAtomTypeCopyWith(
          ConstructedAtomType value, $Res Function(ConstructedAtomType) then) =
      _$ConstructedAtomTypeCopyWithImpl<$Res>;
  $Res call({String typeConstructorName, Map<String, AtomType> typeVarMap});
}

/// @nodoc
class _$ConstructedAtomTypeCopyWithImpl<$Res>
    extends _$AtomTypeCopyWithImpl<$Res>
    implements $ConstructedAtomTypeCopyWith<$Res> {
  _$ConstructedAtomTypeCopyWithImpl(
      ConstructedAtomType _value, $Res Function(ConstructedAtomType) _then)
      : super(_value, (v) => _then(v as ConstructedAtomType));

  @override
  ConstructedAtomType get _value => super._value as ConstructedAtomType;

  @override
  $Res call({
    Object? typeConstructorName = freezed,
    Object? typeVarMap = freezed,
  }) {
    return _then(ConstructedAtomType(
      typeConstructorName == freezed
          ? _value.typeConstructorName
          : typeConstructorName // ignore: cast_nullable_to_non_nullable
              as String,
      typeVarMap == freezed
          ? _value.typeVarMap
          : typeVarMap // ignore: cast_nullable_to_non_nullable
              as Map<String, AtomType>,
    ));
  }
}

/// @nodoc

class _$ConstructedAtomType extends ConstructedAtomType {
  const _$ConstructedAtomType(this.typeConstructorName, this.typeVarMap)
      : super._();

  @override
  final String typeConstructorName;
  @override
  final Map<String, AtomType> typeVarMap;

  @override
  String toString() {
    return 'AtomType.constructedAtomType(typeConstructorName: $typeConstructorName, typeVarMap: $typeVarMap)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ConstructedAtomType &&
            (identical(other.typeConstructorName, typeConstructorName) ||
                const DeepCollectionEquality()
                    .equals(other.typeConstructorName, typeConstructorName)) &&
            (identical(other.typeVarMap, typeVarMap) ||
                const DeepCollectionEquality()
                    .equals(other.typeVarMap, typeVarMap)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(typeConstructorName) ^
      const DeepCollectionEquality().hash(typeVarMap);

  @JsonKey(ignore: true)
  @override
  $ConstructedAtomTypeCopyWith<ConstructedAtomType> get copyWith =>
      _$ConstructedAtomTypeCopyWithImpl<ConstructedAtomType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() intAtomType,
    required TResult Function() integerAtomType,
    required TResult Function() doubleAtomType,
    required TResult Function() textAtomType,
    required TResult Function() boolAtomType,
    required TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)
        constructedAtomType,
  }) {
    return constructedAtomType(typeConstructorName, typeVarMap);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? intAtomType,
    TResult Function()? integerAtomType,
    TResult Function()? doubleAtomType,
    TResult Function()? textAtomType,
    TResult Function()? boolAtomType,
    TResult Function(
            String typeConstructorName, Map<String, AtomType> typeVarMap)?
        constructedAtomType,
    required TResult orElse(),
  }) {
    if (constructedAtomType != null) {
      return constructedAtomType(typeConstructorName, typeVarMap);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntAtomType value) intAtomType,
    required TResult Function(IntegerAtomType value) integerAtomType,
    required TResult Function(DoubleAtomType value) doubleAtomType,
    required TResult Function(TextAtomType value) textAtomType,
    required TResult Function(BoolAtomType value) boolAtomType,
    required TResult Function(ConstructedAtomType value) constructedAtomType,
  }) {
    return constructedAtomType(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntAtomType value)? intAtomType,
    TResult Function(IntegerAtomType value)? integerAtomType,
    TResult Function(DoubleAtomType value)? doubleAtomType,
    TResult Function(TextAtomType value)? textAtomType,
    TResult Function(BoolAtomType value)? boolAtomType,
    TResult Function(ConstructedAtomType value)? constructedAtomType,
    required TResult orElse(),
  }) {
    if (constructedAtomType != null) {
      return constructedAtomType(this);
    }
    return orElse();
  }
}

abstract class ConstructedAtomType extends AtomType {
  const factory ConstructedAtomType(
          String typeConstructorName, Map<String, AtomType> typeVarMap) =
      _$ConstructedAtomType;
  const ConstructedAtomType._() : super._();

  String get typeConstructorName => throw _privateConstructorUsedError;
  Map<String, AtomType> get typeVarMap => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConstructedAtomTypeCopyWith<ConstructedAtomType> get copyWith =>
      throw _privateConstructorUsedError;
}
